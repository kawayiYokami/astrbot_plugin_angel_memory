# Angel Memory 记忆分类改造计划（执行前最终稿）

## 1. 目标

- 引入可配置的记忆分类字段，支持“公共记忆 + 指定分类记忆”的单向保护策略。
- 满足需求：
  - 无分类（默认）记忆可在任意会话被回忆（`public`）。
  - 特定会话空间产生的记忆可标记为指定分类（例如 `家人`），仅在同分类会话可见。
  - 分类与底层平台标识解耦：只改映射，不改历史记忆数据。

## 2. 非目标

- 本阶段不做“全会话硬隔离”。
- 不做一次性阻塞式全量迁移。
- 不改已有记忆的语义内容与向量，仅改 metadata。

## 3. 总体策略（迁移兼容版）

- 新增记忆字段：`memory_scope: str`。
- 默认值：`public`。
- 新增配置映射：`conversation_scope_map: { "<conversation_id>": "<scope_name>" }`。
- 记忆写入按映射决定 scope，检索按“当前 scope + public”过滤。
- 旧数据采用“后台迁移补字段”，迁移窗口内允许临时兼容 `NULL memory_scope`（可配置开关），迁移完成后恢复严格过滤。

## 4. 数据模型与配置变更

### 4.1 数据模型

- `BaseMemory` 新增属性：
  - `memory_scope: str = "public"`
- `to_dict()/from_dict()` 增加该字段的序列化/反序列化。
- 迁移逻辑：
  - 缺失 `memory_scope` 的旧记录在后台初始化阶段补齐为 `public`。

### 4.2 配置项

- `_conf_schema.json` 新增配置：
  - `conversation_scope_map`（object，默认 `{}`）
  - 示例：`{"aiocqhttp:group:12345":"家人","aiocqhttp:friend:67890":"公司"}`
  - 说明：`conversation_id` 统一取事件会话标识（优先 `unified_msg_origin`）。
- `core/config.py` / `PluginContext` 增加读取方法。
- 日志提示：已在 `on_llm_request` 实现“插件启动后每个群首次发言打印一次ID”（已完成）。后续文案改为 `conversation_scope_map`，避免 `group_scope_map` 旧称误导。
- `scope name` 校验（必做）：
  - 允许字符：`[a-zA-Z0-9\u4e00-\u9fff_-]`
  - 对 `conversation_scope_map` 的 value 做启动期校验：
    - 非法值：记录 `warning` 并忽略该映射项
    - 合法值：正常生效

## 5. 业务规则

### 5.1 写入规则（新记忆）

- 统一从事件提取 `conversation_id`（不区分“私聊/群聊”语义）。
- 若 `conversation_scope_map[conversation_id]` 存在，写入 `memory_scope=<映射值>`。
- 若不存在映射，写入 `memory_scope="public"`。
- 结果：所有会话空间都可被配置为私有分类；不配置时默认公共。
- 边界约束（必须）：
  - 工具层（`core_memory_remember` / `core_memory_recall`）只接收并传递 `conversation_id`，不计算也不传递 `memory_scope`。
  - `conversation_scope_map` 查找与 `memory_scope` 推导下沉到 `memory_handlers/cognitive_service`（或其统一入口）内部完成，避免多处重复逻辑与不一致。

### 5.2 检索规则

- 计算当前会话 scope：
  - 统一用 `conversation_id` 查 `conversation_scope_map`，未命中则 `public`。
- 检索 where 条件：
  - 当前 scope 为 `public`：只查 `memory_scope="public"`。
  - 当前 scope 非 `public`：查 `memory_scope in [current_scope, "public"]`。
- 迁移兼容（必须）：
  - 当迁移模式开关开启时，where 条件额外追加 `OR memory_scope IS NULL`，避免迁移窗口“旧记忆不可见”。
  - 迁移完成后关闭迁移模式，恢复严格过滤。

### 5.3 会话ID来源（已确认）

- `event.unified_msg_origin` 可在 DeepMind 和 tools 层获取。
- `tools/core_memory_remember.py` 与 `tools/core_memory_recall.py` 可直接读取 `event.unified_msg_origin`，无需额外接口。
- 若为空或缺失，按严格策略应拒绝写入/召回并记录错误日志。

## 6. 迁移方案（大库友好）

### 6.1 原则

- 不阻塞启动。
- 分批、幂等、可中断、可续跑。
- 仅 metadata 更新，不重算 embedding。

### 6.2 迁移目标

- 将“缺失 `memory_scope`”的旧记忆补齐为 `public`。

### 6.3 执行方式

- 在后台初始化线程执行，挂载在“扫描笔记完成后”的阶段。
  - 建议挂点：`core/background_initializer.py:_perform_initialization_async`
  - 原因：`create_all_components()` 内部已完成文件扫描流程，适合无感追加迁移任务。
- 批次大小建议：`200~500`。
- 每批处理后短暂 sleep（如 50~200ms）降低负载抖动。
- 记录进度日志：
  - 已扫描数量
  - 已补字段数量
  - 剩余估算

### 6.4 过滤策略

- 迁移进行中：执行“严格过滤 + `NULL` 兼容”模式（受 migration-mode flag 控制）。
- 迁移完成后：关闭 migration-mode flag，仅执行严格 `memory_scope` 过滤。

## 7. 代码改动点（预估）

- 模型层：
  - `llm_memory/models/data_models.py`
- 配置层：
  - `_conf_schema.json`
  - `core/config.py`
  - `core/plugin_context.py`
- 主动工具链路（必须改）：
  - `tools/core_memory_remember.py`：仅传递 `conversation_id` 到记忆写入
  - `tools/core_memory_recall.py`：仅传递 `conversation_id`，不拼装 `memory_scope` 过滤
- 检索链路（必须改）：
  - `core/services/retrieval_service.py`：统一传递 `conversation_id`，scope 计算下沉至下层服务
  - `llm_memory/service/memory_manager.py`：`comprehensive_recall/chained_recall` 注入 scope where 条件
  - `llm_memory/components/vector_store.py`：统一 where 组装，支持 `public + current_scope` 条件
- 注入链路（建议改）：
  - `core/services/injection_service.py`：可选标注当前 scope（仅内部日志/调试，不暴露给用户）
- 记忆写入底层（必须改）：
  - `llm_memory/service/memory_handlers.py`：内部根据 `conversation_id` + `conversation_scope_map` 推导 `memory_scope` 并落库
  - `llm_memory/service/cognitive_service.py`：统一入口接收 `conversation_id`，并向 handlers 传递已解析 scope
- 反馈写入链路（第六点，必须改）：
  - `core/deepmind.py`：反思结果落库前，必须携带当前 `conversation_id`
  - `core/services/feedback_service.py`：队列任务 payload 增加 `conversation_id`
  - `llm_memory/service/memory_manager.py`：`feedback/new_memories` 创建记忆时由下层统一推导并写入 `memory_scope`
  - 说明：被动记忆主要从该链路产生，若不改会出现“主链路已隔离、反馈新增未隔离”的权限漏洞
- 迁移任务：
  - 新增迁移模块（建议 `core/migrations/memory_scope_migration.py`）
  - 在后台初始化流程挂载执行点（`core/background_initializer.py`）

## 8. 风险与对策

- 风险：where_filter 条件复杂导致 recall 性能波动。
  - 对策：先小范围压测，必要时增加索引友好条件或分阶段过滤。
- 风险：旧数据格式不一致（部分 metadata 缺字段/格式异常）。
  - 对策：迁移器严格容错，异常记录后跳过，避免任务中断。
- 风险：映射配置被误填（群号错误或 scope 名拼写不一致）。
  - 对策：启动时打印映射摘要，保留会话ID提示日志。
- 风险：迁移中断风险（进度丢失、重复扫描）。
  - 对策：迁移器支持 checkpoint/断点续传；启动时检测未完成迁移并自动续跑。
- 风险：配置热更新风险（`conversation_scope_map` 变更影响不清）。
  - 对策：明确文档：映射变更仅影响新写入/新召回上下文解析；历史 `memory_scope` 不自动改写，需手工迁移或重标记。
- 风险：并发写入一致性（迁移与新写入竞争）。
  - 对策：迁移器只处理 `created_at < migration_start_time` 的记录，避免与新增数据竞争。
- 风险：回滚策略缺失（上线后难降级）。
  - 对策：预置回滚方案：临时按“全部视为 public”降级，或通过 feature flag 关闭 scope 过滤；提供迁移反向工具与日志指引。

## 9. 验收标准

- 功能：
  - `public` 记忆在任意会话可回忆。
  - `家人` scope 记忆仅在 `家人` scope 会话可回忆。
  - 非 `家人` scope 无法召回 `家人` 记忆。
- 迁移：
  - 缺失 `memory_scope` 的旧记忆被补齐为 `public`。
  - 迁移窗口允许 `NULL memory_scope` 可见（仅 migration-mode），迁移结束后恢复严格过滤。
- 性能：
  - 启动时间无明显回退（迁移不阻塞主流程）。
- 可观测：
  - 迁移进度日志可见；异常记录明确。
- 边界与并发（必须）：
  - 并发迁移写入：迁移与新写入互不干扰，无数据丢失。
  - 并发召回：多会话并发召回下 `memory_scope` 过滤稳定且隔离正确。
  - 异常输入：`conversation_id` 为空/非法时有明确错误日志与可观测降级行为。
  - 特殊字符 scope：非法 scope 名按校验规则拒绝并记录 warning。
  - 异常 metadata：迁移可容错跳过损坏记录并持续推进，进度可观测。
  - 运行时映射变更：更新 `conversation_scope_map` 后仅影响新召回/新写入，不改写历史；删除映射不删除历史数据且不阻断可见性规则。

## 10. 实施阶段（建议）

1. Phase A：模型+配置+scope 解析器+主动/被动写入全链路打通
2. Phase B：严格过滤立即上线（不等待迁移）
3. Phase C：后台迁移补齐缺失字段（缺失 -> `public`）
4. Phase D：测试与压测

## 11. 测试与CI补充（必须）

- 单元测试：`tests/test_memory_scope.py`
  - 覆盖 `conversation_id -> memory_scope` 推导逻辑（`core/plugin_context` / `core/services/retrieval_service`）。
  - 覆盖检索 where 条件组装（`llm_memory/components/vector_store.py`），含 migration-mode 下 `OR memory_scope IS NULL`。
- 单元测试：`tests/test_memory_handlers.py`
  - 覆盖 `llm_memory/service/memory_handlers.py` 与 `cognitive_service.py` 的 `remember()/recall()` 是否正确接收 `conversation_id`、推导并落库 `memory_scope`。
- 集成测试：
  - 多 `conversation_id` 场景下验证“私有隔离 + public 可见”。
  - 迁移幂等与容错：`core/migrations/memory_scope_migration.py` 可重复执行、异常记录可恢复。
- CI 接入：
  - 将上述测试加入 CI（至少覆盖 `memory_manager.comprehensive_recall/chained_recall` 与 `core/deepmind` 反馈链路相关回归）。

---

> 当前状态：已完成执行前情报核对，尚未执行记忆分类业务改造代码。
