# 统一记忆接口计划（为 Vector/Simple 分流做准备）

## 1. 现状结论

- 当前**没有**独立的统一记忆接口（Protocol/ABC/Facade）。
- 现有调用方是“默认依赖 `CognitiveService`”，并非真正抽象层。
- 存在越层调用：`tools/core_memory_recall.py` 直接访问 `cognitive_service.memory_manager.comprehensive_recall(...)`，这会阻断后续 SimpleMemory 替换。
- 存在属性泄漏：`core/services/retrieval_service.py` 在外部读取 `memory_handler_factory.handlers`，这不应暴露到统一接口层。

## 2. 目标

- 让 `DeepMind/Bot/tools` 只依赖一个统一记忆接口，不关心底层实现是：
  - 向量实现（当前 `CognitiveService`）
  - 简化实现（未来 `SimpleMemoryService`）
- 开关分流在 `ComponentFactory` 初始化阶段完成（运行期不做动态路由）。

## 3. 统一接口定义（最小可用）

新增 `core/memory_runtime/protocol.py`（命名可调整）：

- `remember(...)`
- `recall(...)`
- `comprehensive_recall(...)`
- `chained_recall(...)`
- `feedback(...)`
- `consolidate_memories(...)`

说明：
- 参数签名尽量与当前 `CognitiveService` 对齐，减少改造面。
- 返回类型固定（去歧义）：
  - `remember(...) -> str`
  - `recall/comprehensive_recall/chained_recall(...) -> List[BaseMemory]`
  - `feedback(...) -> List[BaseMemory]`
  - `consolidate_memories(...) -> None`
- `get_prompt(...)` 不纳入运行时接口，维持静态工具调用路径（`small_model_prompt_builder.py`）。

## 4. 适配器结构（无 Router）

### 4.1 向量适配器

新增 `core/memory_runtime/vector_memory_runtime.py`：
- 内部持有 `CognitiveService`
- 逐个转发统一接口方法
- 处理少量签名差异（如默认参数）

### 4.2 Simple 适配器

新增 `core/memory_runtime/simple_memory_runtime.py`：
- 先做骨架（可先部分方法 no-op + 明确日志）
- 后续接入完整 SQL+tags 能力

### 4.3 初始化期分流（ComponentFactory）

在 `core/component_factory.py` 中按开关实例化并注册：
- `enable_simple_memory=true` -> `SimpleMemoryRuntime`
- `enable_simple_memory=false` -> `VectorMemoryRuntime(cognitive_service)`

说明：
- 不新增运行时 Router，避免多一层无价值代理。

## 5. 注入与替换点

## 5.1 ComponentFactory

- 在 `core/component_factory.py` 中创建并注册统一接口实例（例如组件名 `memory_runtime`）。
- `cognitive_service` 可继续保留为内部依赖，不再作为上层主入口。
- `background_initializer` 仍可直接读取 `cognitive_service.main_collection` 执行向量迁移（实现特有能力，不走统一接口）。

## 5.2 DeepMind

- `core/deepmind.py` 中将 `self.memory_system` 类型依赖由 `CognitiveService` 改为统一接口。
- `retrieval_service`、`feedback_service`、`sleep_service` 仅通过统一接口调用。
- `retrieval_service` 不再访问 `memory_handler_factory.handlers`；调用 `chained_recall(..., memory_handlers=None)` 或直接移除该参数传递，由实现内部处理。

## 5.3 Tools

- `tools/core_memory_remember.py`、`tools/core_memory_recall.py` 改为获取 `memory_runtime` 组件。
- 禁止再访问 `memory_manager` 等内部对象。

## 5.4 PluginContext

- 增加便捷获取方法（可选）：`get_memory_runtime()`。
- 统一由 `get_component("memory_runtime")` 返回主记忆入口。

## 6. 分阶段实施

1. **Phase A（只立接口，不改行为）**
- 新增统一接口 + Vector 适配器（仅向量路径）。
- `ComponentFactory` 注册 `memory_runtime`，并把上层调用切到统一接口。
- 清理 `retrieval_service` 的 `memory_handler_factory` 外部访问。
- 调整 DeepMind 与 tools 改走 `memory_runtime`。
- 功能应与当前保持一致。

2. **Phase B（接入 Simple）**
- 接入 `SimpleMemoryRuntime`。
- `ComponentFactory` 根据 `enable_simple_memory` 分流。
- 补齐 Simple 的 remember/recall/comprehensive_recall/chained_recall/feedback。
- Simple 模式下跳过 `memory_scope` 向量迁移（`background_initializer` 保持向量分支专用）。

3. **Phase C（清理旧耦合）**
- 清理上层对 `cognitive_service` 的直接依赖。
- `cognitive_service` 继续作为组件存在（供向量实现与迁移逻辑使用），但上层业务代码不再直接依赖。

## 7. 验收标准

- DeepMind、tools 不再直接依赖 `CognitiveService` 具体类型。
- 全项目无 `memory_manager` 的上层直连调用（仅底层实现内部允许）。
- 开关 `enable_simple_memory` 能控制运行时实现选择。
- 向量路径回归无行为变化（Phase A 完成标准）。
- `retrieval_service` 中无 `memory_handler_factory` 直连访问。

## 8. 最小回归清单

1. `core_memory_remember` 正常写入（按 scope）。  
2. `core_memory_recall` 正常召回（不访问 `memory_manager` 私有层）。  
3. DeepMind 注入链路可检索记忆并反馈。  
4. 睡眠清理调用 `consolidate_memories()` 正常。  
5. 切换开关后，启动日志明确当前 runtime 类型。  

## 9. 风险与对策

- 风险：接口一次性过大导致实现压力高。  
- 对策：先做 Phase A（Vector-only），保证“先解耦，再分流”。

- 风险：调用方历史上依赖 `CognitiveService` 内部属性。  
- 对策：先全局检索并替换越层调用（重点 `tools/core_memory_recall.py`）。

- 风险：Simple 功能未齐时影响稳定性。  
- 对策：`ComponentFactory` 在功能未齐前固定回退 Vector，并输出清晰日志。  
