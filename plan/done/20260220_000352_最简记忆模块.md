# 最简记忆模块计划（SimpleMemory，基于统一接口）

## 1. 目标

- 实现一套不依赖向量库的最简记忆模块（SQL + tags）。
- 通过开关 `enable_simple_memory` 在初始化阶段分流实现。
- DeepMind / tools 仅依赖统一接口，不感知底层实现。

## 2. 当前基线（已完成）

- 已有统一接口入口：`memory_runtime`。
- `ComponentFactory` 已注册 `memory_runtime`。
- `DeepMind` 与 `tools` 已改为走 `memory_runtime`，不再直连 `memory_manager`。
- 当前 `enable_simple_memory=true` 会明确报错（未实现保护），不会回退向量实现。

## 3. 范围与边界

- 本计划只做 SimpleMemory 的可用实现与接入。
- 不做历史数据迁移（向量库 -> SQL）。
- 不改现有 scope 语义。
- 不改笔记检索：Simple 模式下笔记检索保持关闭/不生效。

## 4. 开关行为（最终）

- `enable_simple_memory=false`：
  - 使用 `VectorMemoryRuntime`（现有向量链路）。
- `enable_simple_memory=true`：
  - 使用 `SimpleMemoryRuntime`（SQL + tags）。
- 若 `enable_simple_memory=true` 且 Simple 组件初始化失败：
  - 启动失败并给出明确错误；禁止静默回退。

## 5. SimpleMemory 数据模型

使用独立 SQL 管理器（`MemorySqlManager`），不复用按 provider 分库的 TagManager。

建议表结构：
- `memory_records`
  - `id TEXT PRIMARY KEY`
  - `memory_type TEXT NOT NULL`
  - `judgment TEXT NOT NULL`
  - `reasoning TEXT NOT NULL`
  - `strength INTEGER NOT NULL`
  - `is_active INTEGER NOT NULL`
  - `memory_scope TEXT NOT NULL`
  - `created_at REAL NOT NULL`
  - `updated_at REAL NOT NULL`
- `memory_tags`
  - `id INTEGER PRIMARY KEY AUTOINCREMENT`
  - `name TEXT NOT NULL UNIQUE`
- `memory_tag_rel`
  - `memory_id TEXT NOT NULL`
  - `tag_id INTEGER NOT NULL`
  - UNIQUE(`memory_id`, `tag_id`)

索引建议：
- `memory_records(memory_scope, created_at)`
- `memory_records(is_active, strength)`
- `memory_tag_rel(tag_id, memory_id)`

### 5.1 全量 tag name 维护策略

- `memory_tags` 作为全量标签主表；同时维护一份内存标签镜像（仅用于检索加速）。
- 写入记忆：
  - 对每个 tag 执行 upsert 到 `memory_tags`。
  - 在 `memory_tag_rel` 建立 `memory_id-tag_id` 关系（去重）。
  - 同步把新增 tag 加入内存镜像。
- 更新记忆 tags：
  - 先删除该记忆旧的 `memory_tag_rel` 关系。
  - 再按新 tags 重建关系。
  - 内存镜像按“增量加入 + 周期性清理”维护（不做逐条精确删减）。
- 删除记忆：
  - 删除 `memory_records` + 对应 `memory_tag_rel`。
  - `memory_tags` 与内存镜像均暂不实时删除孤儿 tag（避免抖动）。
- 标签垃圾回收（可选后台任务）：
  - 定期删除无引用 tag：`memory_tags` 中不存在任何 `memory_tag_rel` 关联的记录。
  - 垃圾回收后重建一次内存标签镜像，确保两者一致。

## 6. 检索算法

### 6.1 标签缓存

- 启动时从 `memory_tags` 表加载全量去重 tag name 到内存集合。
- 记忆写入/删除时同步更新缓存。

### 6.2 检索流程

输入：`query`（由 `query_processor` 处理后的聊天记录文本）。

1. **标签扫描**：遍历内存中的全量 tag name，逐个检查 `tag in query`（子串匹配），收集所有命中的 tag。
2. **反查记忆**：用命中的 tag 集合，通过 `memory_tag_rel` 关联到 `memory_records`，得到候选记忆列表，并统计每条记忆被命中的 tag 数量。
3. **scope 过滤**：对候选记忆严格执行 scope 规则（见第 7 节），过滤不符合的记忆。
4. **排序**：
   - 命中 tag 数量 `desc`
   - 日期（按天粒度）`desc`
   - 强度 `desc`
5. **截断**：按 `limit` 参数截取返回。

### 6.3 示例

假设 tag 库中有：`小明`、`火锅`、`聚餐`、`周报`。

query = `"小明说晚上去吃火锅"`

→ 标签扫描命中：`小明`、`火锅`
→ 反查到记忆 A（含标签 `小明`、`火锅`，命中 2）、记忆 B（含标签 `小明`，命中 1）
→ 排序：A 排在 B 前面

## 7. scope 规则

- `memory_scope="public"`：仅返回 public。
- `memory_scope!=public`：返回 `[current_scope, public]`。
- `memory_scope` 为空/非法：拒绝执行并记录错误。

## 8. 统一接口映射

SimpleMemoryRuntime 需实现并对齐以下接口：
- `remember(...) -> str`
- `recall(...) -> List[BaseMemory]`
- `comprehensive_recall(...) -> List[BaseMemory]`
- `chained_recall(...) -> List[BaseMemory]`
- `feedback(...) -> List[BaseMemory]`
- `consolidate_memories() -> None`

映射策略：
- `recall/comprehensive_recall/chained_recall` 初期可复用同一 SQL 检索核心，确保行为一致。
- `feedback` 至少支持：
  - 强化 `useful_memory_ids`
  - 新增 `new_memories`
  - 合并 `merge_groups`

## 9. 代码改动点

1. 新增：`core/memory_runtime/simple_memory_runtime.py`  
2. 新增：`llm_memory/components/memory_sql_manager.py`（独立 SQL 记忆管理）  
3. 修改：`core/component_factory.py`
   - 按 `enable_simple_memory` 选择 `SimpleMemoryRuntime/VectorMemoryRuntime`
4. 保持：`core/deepmind.py`、`tools/*` 继续只依赖 `memory_runtime`（无需再改调用形态）
5. 可选：`core/plugin_context.py` 补充 `get_memory_runtime()` 使用文档说明

## 10. 日志与可观测

启动日志必须明确：
- `记忆运行时: VectorMemoryRuntime`
- `记忆运行时: SimpleMemoryRuntime`

请求日志建议包含：
- 当前 runtime 类型
- 召回候选数 / 返回数
- SQL 查询耗时

## 11. 验收标准

- `enable_simple_memory=true` 时成功实例化 SimpleMemoryRuntime 并可用。
- `enable_simple_memory=false` 时保持现有向量行为不变。
- 工具 `core_memory_remember/core_memory_recall` 在两种 runtime 下均可工作。
- scope 过滤在 Simple 模式下严格生效。
- Simple 模式下笔记检索不生效且有清晰提示（非静默失败）。

## 12. 最小回归清单

1. `enable_simple_memory=false`：
   - 常规对话 recall/feedback 正常。
2. `enable_simple_memory=true`：
   - remember 写入成功；
   - recall 按 tags 命中次数/日期/强度排序正确；
   - scope 过滤正确；
   - feedback 三分支可运行（useful/new/merge）。
3. 开关切换后日志能准确显示 runtime 类型。
4. Simple 初始化失败时，启动直接报错（不回退）。

## 13. 风险与对策

- 风险：Simple 检索在大数据量下慢。  
- 对策：补齐必要索引，并限制默认召回上限。

- 风险：接口兼容不齐导致上层异常。  
- 对策：以统一接口方法签名为准，先补齐最小行为再优化。

- 风险：误回退到向量实现掩盖问题。  
- 对策：保留“开启 Simple 失败即报错”的硬策略。  
